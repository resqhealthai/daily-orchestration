<!DOCTYPE html>
<html>
<head>
    <title>ResQ Smart Viewer</title>
    <meta charset="utf-8">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        .error { color: #ff4444; padding: 40px; text-align: center; margin-top: 20%; }
    </style>
    <script crossorigin src="https://api.daily.co/daily.js"></script>
</head>
<body>
    <div id="error-msg" class="error" style="display:none;"></div>
    
    <script>
        function showError(title, detail) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerHTML = `<h1>${title}</h1><p>${detail || ''}</p>`;
        }

        async function init() {
            const params = new URLSearchParams(window.location.search);
            const roomUrl = params.get('roomUrl');
            const mode = params.get('mode') || 'face';

            if (!roomUrl) { showError("Config Error", "No roomUrl"); return; }

            // 1. CREATE FRAME
            const callFrame = window.DailyIframe.createFrame(document.body, {
                showLeaveButton: false,
                showFullscreenButton: false,
                iframeStyle: { width: '100%', height: '100%', border: '0', zIndex: 9999 }
            });

            console.log(`Joining ${roomUrl} in ${mode} mode...`);

            try {
                // 2. JOIN
                await callFrame.join({ 
                    url: roomUrl,
                    showLocalVideo: false,
                    startVideoOff: true,
                    startAudioOff: false,
                    userName: `Display-${mode.toUpperCase()}`,
                    activeSpeakerMode: false // Start in Grid mode
                });

                // 3. LISTEN FOR EVENTS
                // This is the correct way to handle layout changes
                
                const updateLayout = () => {
                    const participants = callFrame.participants();
                    
                    // Logic: We must "pin" the participant we want to see.
                    // Pinning forces them to fill the screen in Active Speaker mode.
                    
                    let targetId = null;

                    for (const id in participants) {
                        const p = participants[id];
                        if (p.local) continue; // Skip self

                        if (mode === 'face') {
                            // Look for a user who HAS video but IS NOT a screen share
                            if (p.video && !p.screen) {
                                targetId = id;
                                break; 
                            }
                        } else if (mode === 'screen') {
                            // Look for a user who HAS screen sharing active
                            if (p.screen) {
                                targetId = id;
                                break;
                            }
                        }
                    }

                    if (targetId) {
                        // FORCE FOCUS ON THIS ID
                        console.log(`[${mode}] Pinning participant: ${targetId}`);
                        
                        // We set mode to 'active-speaker' which shows one big video
                        callFrame.setShowNamesMode(false); // Hide names
                        callFrame.updateParticipant(targetId, {
                            setSubscribedTracks: { audio: true, video: true, screenVideo: true }, // Ensure we have data
                            styles: { cam: { width: '100%', height: '100%' }, screen: { width: '100%', height: '100%' } }
                        });
                        
                        // "Spotlight" them (Pin logic equivalent)
                         // Note: daily-js doesn't have a direct 'pin' method exposed easily in 1.0 without custom layouts,
                         // So we simulate it by setting the track priority or ensuring they are the only ones subscribed?
                         // Actually, keeping it simple:
                         
                         // REVERT TO SUBSCRIPTION LOGIC (It works if we don't block everything)
                         // We will subscribe to the target, and UNSUBSCRIBE from everyone else.
                         
                         for (const otherId in participants) {
                             if (otherId !== targetId && !participants[otherId].local) {
                                 callFrame.updateParticipant(otherId, {
                                     setSubscribedTracks: { audio: true, video: false, screenVideo: false }
                                 });
                             }
                         }
                         
                         // Ensure target is fully subscribed
                         callFrame.updateParticipant(targetId, {
                             setSubscribedTracks: { 
                                 audio: true, 
                                 video: (mode === 'face'), 
                                 screenVideo: (mode === 'screen') 
                             }
                         });
                    }
                };

                // Run layout logic on events
                callFrame.on('participant-joined', updateLayout);
                callFrame.on('participant-updated', updateLayout);
                callFrame.on('active-speaker-change', updateLayout);
                
                // Run once immediately
                setTimeout(updateLayout, 1000);
                setTimeout(updateLayout, 3000); // Retry in case video was slow to start

            } catch (e) {
                showError("Join Failed", e.message);
            }
        }

        window.addEventListener('load', () => setTimeout(init, 500));
    </script>
</body>
</html>
