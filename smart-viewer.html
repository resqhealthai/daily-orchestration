<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ResQ Smart Viewer</title>
    <script src="https://unpkg.com/@daily-co/daily-js"></script>
    <style>
        body { margin: 0; padding: 0; background: black; overflow: hidden; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { width: 100%; height: 100%; object-fit: cover; }
        #status { position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.5); font-family: monospace; z-index: 100; pointer-events: none;}
    </style>
</head>
<body>
    <div id="status">Waiting for Instructor...</div>
    <video id="videoEl" autoplay playsinline></video>
    <audio id="audioEl" autoplay></audio>

    <script>
        const log = (msg) => {
            const el = document.getElementById('status');
            el.innerText = msg;
            console.log(`[SmartViewer] ${msg}`);
        };

        // 1. Get Params
        const params = new URLSearchParams(window.location.search);
        const ROOM_URL = params.get('roomUrl') || params.get('url'); 
        const MODE = params.get('mode') || 'face';

        if (!ROOM_URL) {
            log("Error: No 'roomUrl' parameter provided.");
            throw new Error("Missing Room URL");
        }

        // 2. Configure Call Object
        const call = window.DailyIframe.createCallObject({
            subscribeToTracksAutomatically: false,
            dailyConfig: {
                experimentalChromeVideoMuteLightOff: true
            }
        });

        const videoEl = document.getElementById('videoEl');
        const audioEl = document.getElementById('audioEl');

        // 3. Helper: Subscription Logic
        // We broadly subscribe to remote participants, but the RENDERER (handleTrack)
        // is the final gatekeeper that decides what actually shows up.
        const updateSubscriptions = (participant) => {
            if (participant.local) return; // Never subscribe to self

            let subs = { audio: false, video: false, screenVideo: false };

            if (MODE === 'face') {
                // Monitor 1: Needs Video + Audio
                subs = { audio: true, video: true, screenVideo: false };
            } else if (MODE === 'screen') {
                // Monitor 2: Needs Screen ONLY
                subs = { audio: false, video: false, screenVideo: true };
            }

            log(`Requesting tracks from ${participant.user_name || participant.session_id}`);
            call.updateParticipant(participant.session_id, { setSubscribedTracks: subs });
        };

        // 4. Helper: Track Renderer (The Absolute Gatekeeper)
        const handleTrack = (evt) => {
            const track = evt.track;
            const participant = evt.participant;

            if (!track || !participant) return;

            // --- SAFETY LOCK 1: Is this ME? ---
            // We compare IDs directly to be 100% sure.
            const localId = call.participants().local?.session_id;
            const isLocal = participant.local || (localId && participant.session_id === localId);

            if (isLocal) {
                // log("Blocked local track attempt."); // Optional debug
                return;
            }
            // ----------------------------------

            // --- FILTER: Mode Logic ---
            if (MODE === 'face') {
                // In FACE mode: We want CAMERA video (not screen)
                // If this is a screen share, ignore it.
                if (track.kind === 'video' && participant.screen) return;
            } 
            else if (MODE === 'screen') {
                // In SCREEN mode: We want SCREEN video only
                // If this is NOT a screen share (i.e. a face camera), ignore it.
                if (track.kind === 'video' && !participant.screen) return;
            }

            // --- RENDER ---
            const targetEl = track.kind === 'video' ? videoEl : audioEl;

            // Don't interrupt if we are already playing this exact track ID
            const currentTracks = targetEl.srcObject?.getTracks() || [];
            if (currentTracks.some(t => t.id === track.id)) return;

            log(`Rendering ${track.kind} from ${participant.user_name || participant.session_id}`);
            
            const newStream = new MediaStream([track]);
            targetEl.srcObject = newStream;

            targetEl.onloadedmetadata = () => {
                targetEl.play().catch(e => log(`Autoplay failed: ${e.message}`));
            };
        };

        // 5. Cleanup Helper
        const handleParticipantLeft = (evt) => {
            log(`Participant left: ${evt.participant.user_name}`);
            
            // If the person currently on screen leaves, clear the screen.
            // This prevents "frozen face" or falling back to weird states.
            // We check if the track currently playing belongs to the person who left.
            // (Simplification: We just clear if *any* remote user leaves to be safe, 
            //  or we can just let the next join overwrite it. For kiosks, clearing is safer.)
            
            // Re-scan participants to see if anyone is left
            const participants = call.participants();
            const remoteCount = Object.values(participants).filter(p => !p.local).length;

            if (remoteCount === 0) {
                log("Instructor left. Waiting...");
                videoEl.srcObject = null; // Go black
                audioEl.srcObject = null; // Silence
            }
        };

        // 6. Event Listeners
        call.on('participant-joined', (evt) => updateSubscriptions(evt.participant));
        call.on('participant-updated', (evt) => updateSubscriptions(evt.participant));
        call.on('track-started', handleTrack);
        call.on('participant-left', handleParticipantLeft);

        call.on('joined-meeting', (evt) => {
            log(`Joined ${MODE} mode. Scanning...`);
            const participants = call.participants();
            for (const id in participants) {
                updateSubscriptions(participants[id]);
            }
        });

        call.on('error', (evt) => log(`Daily Error: ${evt.errorMsg}`));

        // 7. Join Room
        call.join({ url: ROOM_URL });

    </script>
</body>
</html>
